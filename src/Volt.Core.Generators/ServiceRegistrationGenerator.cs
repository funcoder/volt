using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Volt.Core.Generators;

/// <summary>
/// Source generator that discovers classes in Services/ folder
/// and auto-registers them in the DI container as scoped services.
/// Classes with [VoltService] attribute can specify a different lifetime.
/// </summary>
[Generator]
public class ServiceRegistrationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var serviceClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetServiceInfo(ctx))
            .Where(static s => s is not null)
            .Select(static (s, _) => s!.Value);

        var collected = serviceClasses.Collect();

        context.RegisterSourceOutput(collected, static (spc, services) =>
        {
            if (services.IsEmpty) return;
            GenerateServiceRegistration(spc, services);
        });
    }

    private static ServiceInfo? GetServiceInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        if (symbol is null || symbol.IsAbstract || symbol.IsStatic) return null;

        var filePath = classDecl.SyntaxTree.FilePath.Replace("\\", "/");
        var isInServicesFolder = filePath.Contains("/Services/");
        if (!isInServicesFolder) return null;

        var lifetime = "Scoped";

        foreach (var attr in symbol.GetAttributes())
        {
            if (attr.AttributeClass?.Name == "VoltServiceAttribute"
                && attr.ConstructorArguments.Length > 0)
            {
                var lifetimeValue = attr.ConstructorArguments[0].Value?.ToString();
                if (lifetimeValue is not null)
                {
                    lifetime = lifetimeValue switch
                    {
                        "0" => "Singleton",
                        "1" => "Scoped",
                        "2" => "Transient",
                        _ => "Scoped"
                    };
                }
            }
        }

        var interfaceName = FindMatchingInterface(symbol);

        return new ServiceInfo(
            symbol.Name,
            symbol.ContainingNamespace.ToDisplayString(),
            interfaceName,
            lifetime);
    }

    private static string? FindMatchingInterface(INamedTypeSymbol symbol)
    {
        foreach (var iface in symbol.Interfaces)
        {
            if (iface.Name == $"I{symbol.Name}")
            {
                return iface.ToDisplayString();
            }
        }
        return null;
    }

    private static void GenerateServiceRegistration(
        SourceProductionContext context,
        ImmutableArray<ServiceInfo> services)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();

        var namespaces = services
            .SelectMany(s => new[] { s.Namespace, s.InterfaceFullName }
                .Where(n => n is not null)
                .Select(n => GetNamespace(n!)))
            .Distinct()
            .OrderBy(n => n);

        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine("namespace Volt.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated service registration for convention-discovered services.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class VoltServiceRegistration");
        sb.AppendLine("{");
        sb.AppendLine("    public static IServiceCollection AddVoltServices(this IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var service in services)
        {
            if (service.InterfaceFullName is not null)
            {
                sb.AppendLine($"        services.Add{service.Lifetime}<{GetTypeName(service.InterfaceFullName)}, {service.Name}>();");
            }
            else
            {
                sb.AppendLine($"        services.Add{service.Lifetime}<{service.Name}>();");
            }
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("VoltServiceRegistration.g.cs", sb.ToString());
    }

    private static string GetNamespace(string fullName)
    {
        var lastDot = fullName.LastIndexOf('.');
        return lastDot > 0 ? fullName.Substring(0, lastDot) : fullName;
    }

    private static string GetTypeName(string fullName)
    {
        var lastDot = fullName.LastIndexOf('.');
        return lastDot > 0 ? fullName.Substring(lastDot + 1) : fullName;
    }
}

internal readonly record struct ServiceInfo(
    string Name,
    string Namespace,
    string? InterfaceFullName,
    string Lifetime);
